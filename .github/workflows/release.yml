---
name: Release images

'on':
  workflow_dispatch:
    inputs:
      pr-number:
        description: Pull request number to merge after a successful release run
        required: true
        type: string

env:
  REGISTRY: ghcr.io

jobs:
  changes:
    runs-on: ubuntu-latest
    outputs:
      base: ${{ steps.filter.outputs.base }}
      server: ${{ steps.filter.outputs.server }}
      personal: ${{ steps.filter.outputs.personal }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect image changes
        id: filter
        uses: dorny/paths-filter@v3
        with:
          base: main
          ref: ${{ github.ref }}
          filters: |
            base:
              - 'Containerfiles/Containerfile.base'
              - 'files/common/**'
            server:
              - 'Containerfiles/Containerfile.server'
              - 'files/server/**'
            personal:
              - 'Containerfiles/Containerfile.personal'
              - 'files/personal/**'

  build-base:
    needs: changes
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      owner: ${{ steps.prepare.outputs.owner }}
      base_sha: ${{ steps.prepare.outputs.base_sha }}
      base_latest: ${{ steps.prepare.outputs.base_latest }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y podman uidmap

      - name: Log in to GHCR
        env:
          CR_PAT: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          echo "${CR_PAT}" | sudo podman login \
            "${REGISTRY}" \
            -u "${{ github.actor }}" \
            --password-stdin

      - name: Prepare image tags
        id: prepare
        run: |
          OWNER_INPUT="${GITHUB_REPOSITORY_OWNER}"
          OWNER="$(
            echo "${OWNER_INPUT}" | tr '[:upper:]' '[:lower:]'
          )"
          BASE_SHA="${REGISTRY}/${OWNER}/bootc-base:${GITHUB_SHA}"
          BASE_LATEST="${REGISTRY}/${OWNER}/bootc-base:latest"
          {
            echo "owner=${OWNER}"
            echo "base_sha=${BASE_SHA}"
            echo "base_latest=${BASE_LATEST}"
          } >> "${GITHUB_OUTPUT}"

      - name: Build and push base image
        if: needs.changes.outputs.base == 'true'
        run: |
          set -euo pipefail
          BASE_LOCAL_SHA="localhost/bootc-base:${GITHUB_SHA}"
          BASE_LOCAL_LATEST="localhost/bootc-base:latest"
          BASE_REMOTE_SHA="${{ steps.prepare.outputs.base_sha }}"
          BASE_REMOTE_LATEST="${{ steps.prepare.outputs.base_latest }}"
          sudo podman build \
            --pull=always \
            --tag "${BASE_LOCAL_SHA}" \
            -f Containerfiles/Containerfile.base \
            .
          sudo podman tag "${BASE_LOCAL_SHA}" "${BASE_LOCAL_LATEST}"
          sudo podman tag "${BASE_LOCAL_SHA}" "${BASE_REMOTE_SHA}"
          sudo podman tag "${BASE_LOCAL_SHA}" "${BASE_REMOTE_LATEST}"
          sudo podman push "${BASE_REMOTE_SHA}"
          sudo podman push "${BASE_REMOTE_LATEST}"

      - name: Reuse existing base image
        if: needs.changes.outputs.base != 'true'
        run: |
          set -euo pipefail
          BASE_REMOTE_SHA="${{ steps.prepare.outputs.base_sha }}"
          BASE_REMOTE_LATEST="${{ steps.prepare.outputs.base_latest }}"
          sudo podman pull "${BASE_REMOTE_LATEST}"
          sudo podman tag "${BASE_REMOTE_LATEST}" "${BASE_REMOTE_SHA}"
          sudo podman push "${BASE_REMOTE_SHA}"

  build-server:
    needs:
      - build-base
      - changes
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y podman uidmap

      - name: Log in to GHCR
        env:
          CR_PAT: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          echo "${CR_PAT}" | sudo podman login \
            "${REGISTRY}" \
            -u "${{ github.actor }}" \
            --password-stdin

      - name: Pull base image
        if: >-
          needs.changes.outputs.base == 'true' ||
          needs.changes.outputs.server == 'true'
        run: |
          sudo podman pull "${{ needs.build-base.outputs.base_sha }}"

      - name: Build and push server image
        if: >-
          needs.changes.outputs.base == 'true' ||
          needs.changes.outputs.server == 'true'
        run: |
          set -euo pipefail
          OWNER="${{ needs.build-base.outputs.owner }}"
          BASE_SHA="${{ needs.build-base.outputs.base_sha }}"
          SERVER_LOCAL_SHA="localhost/bootc-server:${GITHUB_SHA}"
          SERVER_LOCAL_LATEST="localhost/bootc-server:latest"
          SERVER_REMOTE_BASE="${REGISTRY}/${OWNER}/bootc-server"
          SERVER_REMOTE_SHA="${SERVER_REMOTE_BASE}:${GITHUB_SHA}"
          SERVER_REMOTE_LATEST="${SERVER_REMOTE_BASE}:latest"
          sudo podman build \
            --build-arg BASE_IMAGE="${BASE_SHA}" \
            --tag "${SERVER_LOCAL_SHA}" \
            -f Containerfiles/Containerfile.server \
            .
          sudo podman tag "${SERVER_LOCAL_SHA}" "${SERVER_LOCAL_LATEST}"
          sudo podman tag "${SERVER_LOCAL_SHA}" "${SERVER_REMOTE_SHA}"
          sudo podman tag "${SERVER_LOCAL_SHA}" "${SERVER_REMOTE_LATEST}"
          sudo podman push "${SERVER_REMOTE_SHA}"
          sudo podman push "${SERVER_REMOTE_LATEST}"

      - name: Reuse existing server image
        if: >-
          needs.changes.outputs.base != 'true' &&
          needs.changes.outputs.server != 'true'
        run: |
          set -euo pipefail
          OWNER="${{ needs.build-base.outputs.owner }}"
          SERVER_REMOTE_BASE="${REGISTRY}/${OWNER}/bootc-server"
          SERVER_REMOTE_SHA="${SERVER_REMOTE_BASE}:${GITHUB_SHA}"
          SERVER_REMOTE_LATEST="${SERVER_REMOTE_BASE}:latest"
          sudo podman pull "${SERVER_REMOTE_LATEST}"
          sudo podman tag "${SERVER_REMOTE_LATEST}" "${SERVER_REMOTE_SHA}"
          sudo podman push "${SERVER_REMOTE_SHA}"

  build-personal:
    needs:
      - build-base
      - changes
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y podman uidmap

      - name: Log in to GHCR
        env:
          CR_PAT: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          echo "${CR_PAT}" | sudo podman login \
            "${REGISTRY}" \
            -u "${{ github.actor }}" \
            --password-stdin

      - name: Pull base image
        if: >-
          needs.changes.outputs.base == 'true' ||
          needs.changes.outputs.personal == 'true'
        run: |
          sudo podman pull "${{ needs.build-base.outputs.base_sha }}"

      - name: Build and push personal image
        if: >-
          needs.changes.outputs.base == 'true' ||
          needs.changes.outputs.personal == 'true'
        run: |
          set -euo pipefail
          OWNER="${{ needs.build-base.outputs.owner }}"
          BASE_SHA="${{ needs.build-base.outputs.base_sha }}"
          PERSONAL_LOCAL_SHA="localhost/bootc-personal:${GITHUB_SHA}"
          PERSONAL_LOCAL_LATEST="localhost/bootc-personal:latest"
          PERSONAL_REMOTE_BASE="${REGISTRY}/${OWNER}/bootc-personal"
          PERSONAL_REMOTE_SHA="${PERSONAL_REMOTE_BASE}:${GITHUB_SHA}"
          PERSONAL_REMOTE_LATEST="${PERSONAL_REMOTE_BASE}:latest"
          sudo podman build \
            --build-arg BASE_IMAGE="${BASE_SHA}" \
            --tag "${PERSONAL_LOCAL_SHA}" \
            -f Containerfiles/Containerfile.personal \
            .
          sudo podman tag "${PERSONAL_LOCAL_SHA}" "${PERSONAL_LOCAL_LATEST}"
          sudo podman tag "${PERSONAL_LOCAL_SHA}" "${PERSONAL_REMOTE_SHA}"
          sudo podman tag "${PERSONAL_LOCAL_SHA}" "${PERSONAL_REMOTE_LATEST}"
          sudo podman push "${PERSONAL_REMOTE_SHA}"
          sudo podman push "${PERSONAL_REMOTE_LATEST}"

      - name: Reuse existing personal image
        if: >-
          needs.changes.outputs.base != 'true' &&
          needs.changes.outputs.personal != 'true'
        run: |
          set -euo pipefail
          OWNER="${{ needs.build-base.outputs.owner }}"
          PERSONAL_REMOTE_BASE="${REGISTRY}/${OWNER}/bootc-personal"
          PERSONAL_REMOTE_SHA="${PERSONAL_REMOTE_BASE}:${GITHUB_SHA}"
          PERSONAL_REMOTE_LATEST="${PERSONAL_REMOTE_BASE}:latest"
          sudo podman pull "${PERSONAL_REMOTE_LATEST}"
          sudo podman tag "${PERSONAL_REMOTE_LATEST}" "${PERSONAL_REMOTE_SHA}"
          sudo podman push "${PERSONAL_REMOTE_SHA}"

  merge-pr:
    needs:
      - build-base
      - build-server
      - build-personal
      - changes
    if: ${{ success() }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - name: Merge pull request
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const prInput = context.payload.inputs['pr-number'];
            const prNumber = Number.parseInt(prInput, 10);

            if (!Number.isInteger(prNumber) || prNumber <= 0) {
              const invalidNumberMessage =
                `Invalid pull request number provided: '${prInput}'.`;
              core.setFailed(invalidNumberMessage);
              return;
            }

            const prResponse = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });
            const pr = prResponse.data;

            if (pr.state !== 'open') {
              const notOpenMessage =
                `Pull request #${prNumber} is not open (state: ${pr.state}).`;
              core.setFailed(notOpenMessage);
              return;
            }

            if (pr.draft) {
              core.setFailed(`Pull request #${prNumber} is marked as draft.`);
              return;
            }

            if (pr.base.ref !== 'main') {
              const wrongBaseMessage =
                `Pull request #${prNumber} targets '${pr.base.ref}' ` +
                "instead of 'main'.";
              core.setFailed(wrongBaseMessage);
              return;
            }

            const workflowSha = process.env.GITHUB_SHA;
            if (pr.head.sha !== workflowSha) {
              const shaMismatchMessage =
                `Pull request head SHA ${pr.head.sha} does not match ` +
                `workflow commit ${workflowSha}.`;
              core.setFailed(shaMismatchMessage);
              return;
            }

            if (pr.mergeable === false || pr.mergeable_state !== 'clean') {
              const mergeableState = pr.mergeable_state ?? 'unknown';
              const notMergeableMessage =
                `Pull request #${prNumber} is not mergeable (state: ` +
                `${mergeableState}).`;
              core.setFailed(notMergeableMessage);
              return;
            }

            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              merge_method: 'merge',
            });
            core.info(`Pull request #${prNumber} merged successfully.`);
